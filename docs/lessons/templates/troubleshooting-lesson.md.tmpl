---
id: TROUBLE-###-descriptive-title
title: "Troubleshooting: Problem Description"
category: troubleshooting
tags: [troubleshooting, debugging, issue-resolution]
project_type: [{{PROJECT_TYPE}}, other]
difficulty: intermediate
impact: high
created: {{DATE}}
updated: {{DATE}}
author: {{AGENT_NAME}}
surface_when: ["DEV", "QA", "ARCHITECT", "ORCHESTRATOR"]
surface_contexts: ["*"]
related_lessons: []
confidence: 0.95
usage_count: 0
success_rate: 1.0
issue_type: ["configuration", "integration", "performance", "deployment"]
resolution_time: "30 minutes"
---

# Troubleshooting: Problem Description

## Problem Summary

**Issue Description:**
Provide a clear, concise description of the problem that developers encounter.

**Symptoms:**
- List the visible symptoms and error messages
- Include performance indicators or behavior changes  
- Describe the impact on development or production

**When This Problem Occurs:**
- Specific scenarios or conditions that trigger the issue
- Environmental factors (development vs production, specific configurations)
- Timing or sequence of events that lead to the problem

## Error Identification

### Common Error Messages
```bash
# Typical error output that developers see
Error: Connection failed to service
  at DatabaseConnection.connect (db.js:45)
  at Service.initialize (service.js:23)
  Code: ECONNREFUSED
  Port: 5432
  Host: localhost
```

### Problem Indicators
- **Performance Symptoms**: Response times, resource usage patterns
- **Behavioral Changes**: Unexpected application behavior or crashes
- **Log Patterns**: Specific log entries that indicate the problem
- **User Impact**: How the problem affects end users or development workflow

### Diagnostic Questions
1. **When did the problem first appear?**
2. **What changed recently?** (code, configuration, environment)
3. **Is the problem consistent or intermittent?**
4. **Which environments are affected?** (development, staging, production)
5. **What error messages appear in logs?**

## Root Cause Analysis

### Primary Cause
Identify the fundamental reason for the problem:
- Configuration issues (incorrect settings, missing environment variables)
- Integration problems (API changes, service dependencies)
- Resource limitations (memory, disk space, network connectivity)
- Code defects (logic errors, race conditions, memory leaks)

### Contributing Factors
Secondary issues that compound the primary problem:
- Environmental differences between development and production
- Timing issues or dependency startup ordering
- Resource contention or scaling limitations
- Configuration drift or version mismatches

### Investigation Process
```bash
# Step-by-step diagnostic commands
echo "Step 1: Check service status"
docker-compose ps
systemctl status service-name

echo "Step 2: Examine logs"
docker-compose logs service-name
tail -f /var/log/application.log

echo "Step 3: Verify configuration"
cat config/database.yml
env | grep DATABASE

echo "Step 4: Test connectivity"
telnet database-host 5432
ping external-api.com

echo "Step 5: Check resource usage"
df -h
free -h
top
```

## Solution Implementation

### Immediate Fix (Quick Resolution)
```bash
# Commands to resolve the immediate problem
# Step 1: Stop the problematic service
docker-compose stop service-name

# Step 2: Apply the fix
export DATABASE_URL="postgresql://user:pass@localhost:5432/db"
# or edit configuration file

# Step 3: Restart the service  
docker-compose up -d service-name

# Step 4: Verify the fix
curl -f http://localhost:3000/health
docker-compose logs service-name
```

### Permanent Solution (Prevent Recurrence)
```yaml
# Configuration changes to prevent the problem
# docker-compose.yml
version: '3.8'
services:
  app:
    depends_on:
      database:
        condition: service_healthy
    environment:
      - DATABASE_URL=${DATABASE_URL}
      - DATABASE_RETRY_ATTEMPTS=5
      - DATABASE_RETRY_DELAY=2000
    restart: unless-stopped
  
  database:
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 10s
      timeout: 5s
      retries: 5
```

```javascript
// Code changes to handle the issue gracefully
class DatabaseConnection {
  constructor(config) {
    this.config = {
      retryAttempts: 5,
      retryDelay: 2000,
      ...config
    };
  }
  
  async connect() {
    for (let attempt = 1; attempt <= this.config.retryAttempts; attempt++) {
      try {
        await this.establishConnection();
        console.log('Database connected successfully');
        return;
      } catch (error) {
        console.log(`Connection attempt ${attempt} failed: ${error.message}`);
        
        if (attempt === this.config.retryAttempts) {
          throw new Error(`Failed to connect after ${attempt} attempts`);
        }
        
        await this.delay(this.config.retryDelay);
      }
    }
  }
  
  delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
```

### Validation Steps
```bash
# Commands to verify the solution works
echo "Testing the fix..."

# Test 1: Verify service starts successfully
docker-compose up -d
sleep 10
docker-compose ps | grep -v Exit

# Test 2: Verify application responds correctly
curl -f http://localhost:3000/api/health
if [ $? -eq 0 ]; then
  echo "✅ Health check passed"
else
  echo "❌ Health check failed"
fi

# Test 3: Verify under load
for i in {1..10}; do
  curl -s http://localhost:3000/api/test > /dev/null &
done
wait
echo "✅ Load test completed"

# Test 4: Verify logs show no errors
docker-compose logs --tail=50 | grep -i error
if [ $? -ne 0 ]; then
  echo "✅ No errors in recent logs"
else
  echo "⚠️  Errors found in logs - investigate further"
fi
```

## Prevention Strategies

### Monitoring & Alerting
```yaml
# Monitoring configuration to catch the problem early
alerts:
  - name: service_connection_failure
    condition: connection_errors > 5
    duration: 2m
    action: notify_team
    
  - name: service_response_time_high
    condition: avg_response_time > 2000ms
    duration: 5m
    action: investigate
    
  - name: database_connection_pool_exhausted
    condition: active_connections > 90% of pool_size
    duration: 1m
    action: scale_up
```

### Configuration Best Practices
- Use environment variables for configuration
- Implement configuration validation on startup
- Document all configuration options with examples
- Use configuration templates with sane defaults
- Implement graceful degradation when possible

### Development Practices
- Add comprehensive error handling and logging
- Implement retry logic with exponential backoff
- Use health checks and readiness probes
- Add integration tests for critical dependencies
- Document known failure modes and recovery procedures

### Infrastructure Improvements
```bash
# Infrastructure changes to prevent the issue
# Add to deployment scripts

# 1. Pre-deployment validation
validate_config() {
  if [ -z "$DATABASE_URL" ]; then
    echo "ERROR: DATABASE_URL not set"
    exit 1
  fi
}

# 2. Graceful deployment with health checks
deploy_with_health_check() {
  docker-compose up -d
  
  # Wait for services to be healthy
  timeout 60s bash -c 'until curl -f http://localhost:3000/health; do sleep 2; done'
  
  if [ $? -eq 0 ]; then
    echo "✅ Deployment successful"
  else
    echo "❌ Deployment failed - rolling back"
    docker-compose down
    exit 1
  fi
}
```

## Testing & Validation

### Reproduce the Problem
```bash
# Steps to reliably reproduce the original issue
echo "Reproducing the problem for validation..."

# 1. Create conditions that cause the problem
unset DATABASE_URL
docker-compose down
docker-compose up -d app  # Start app without database

# 2. Verify the problem occurs
sleep 5
curl http://localhost:3000/api/test
# Should fail with connection error

# 3. Apply the solution
export DATABASE_URL="postgresql://user:pass@localhost:5432/db"
docker-compose up -d database
sleep 10
docker-compose restart app

# 4. Verify the problem is resolved
curl http://localhost:3000/api/test
# Should succeed
```

### Automated Testing
```javascript
// Test that validates the fix works
describe('Database Connection Issue Resolution', () => {
  it('should handle database connection failures gracefully', async () => {
    // Simulate database unavailability
    await database.disconnect();
    
    // Application should retry and eventually succeed
    const service = new DatabaseService();
    const result = await service.connectWithRetry();
    
    expect(result.connected).toBe(true);
    expect(result.attempts).toBeGreaterThan(1);
  });
  
  it('should not crash when database is temporarily unavailable', async () => {
    // Start application
    const app = new Application();
    await app.start();
    
    // Database goes down
    await database.stop();
    
    // Application should continue running
    expect(app.isRunning()).toBe(true);
    
    // Restore database
    await database.start();
    
    // Application should reconnect automatically
    await app.waitForDatabaseConnection();
    expect(app.isDatabaseConnected()).toBe(true);
  });
});
```

## Impact Assessment

**Problem Impact:**
- Development time lost to debugging
- Production downtime or degraded performance
- User experience impact
- Business cost of the problem

**Solution Benefits:**
- Reduced time to resolution (e.g., "from 2 hours to 15 minutes")
- Improved system reliability and resilience
- Better monitoring and early problem detection
- Prevention of similar issues in the future

**Team Knowledge:**
- Improved debugging skills and processes
- Better understanding of system dependencies
- Enhanced monitoring and alerting capabilities
- Documented procedures for similar problems

## Escalation & Support

### When to Escalate
- Problem persists after following this guide
- Solution causes new problems or side effects
- Performance impact is severe or affecting users
- Security implications are suspected

### Support Contacts
- **Infrastructure Team**: For deployment and configuration issues
- **Security Team**: For potential security implications  
- **Database Team**: For database-specific problems
- **On-Call Engineer**: For production emergencies

### Documentation Updates
After resolving the issue:
- [ ] Update troubleshooting documentation
- [ ] Add monitoring for this specific problem
- [ ] Update deployment procedures if needed
- [ ] Share knowledge with team through lesson learned
- [ ] Create or update automated tests

## Related Issues & Resources

### Similar Problems
- TROUBLE-###: Related troubleshooting guide
- LESSON-###: Implementation lesson that prevents this issue
- TECH-###: Technology pattern that addresses root cause

### Documentation References
- [System Architecture](docs/architecture/system-overview.md)
- [Deployment Guide](docs/deployment/production-deployment.md)
- [Monitoring Dashboard](http://monitoring.internal/dashboard)
- [Incident Response Playbook](docs/operations/incident-response.md)

### Tools & Commands
```bash
# Useful diagnostic commands for this type of issue
docker-compose logs --follow service-name
netstat -tuln | grep :5432
ss -tuln | grep :5432
dig database-host.example.com
nslookup database-host.example.com
tcpdump -i any host database-host.example.com
```

---

*This troubleshooting guide typically resolves {{ISSUE_TYPE}} issues in {{RESOLUTION_TIME}} when followed systematically.*